## PROJECT4：SM3的软件实现、优化与应用

本项目旨在深入研究SM3哈希算法，涵盖了从基础算法实现、代码优化、安全漏洞验证到密码学应用的完整流程。

本项目已经成功实现了SM3算法的多种版本，并在此基础上，成功地演示了长度扩展攻击，以及构建了一个包含十万叶子节点的大型Merkle树并验证了存在性证明。整个项目可通过`Makefile`进行一键编译。

### 已实现功能

**1. 完整的开发环境与项目结构**

- 在Windows上成功搭建了基于MSYS2、MinGW-w64的C语言开发环境。
- 构建了模块化的项目仓库，将源码、测试代码和编译脚本分离，易于维护和扩展。

**2. SM3算法实现与验证**

- **基础版 (`sm3_basic`)**: 实现了符合官方标准的SM3哈希算法。
- **优化框架**: 搭建了循环展开 (`sm3_unrolled`) 和SIMD (`sm3_simd`) 的优化框架。
- **正确性验证**: 所有版本的SM3实现均已通过标准测试向量的验证，确保了计算结果的准确性。

**3. 长度扩展攻击 (Length-Extension Attack) 验证**

- 成功实现了针对SM3哈希函数的长度扩展攻击。
- 测试程序 (`test_attack.exe`) 能够完美复现攻击场景：在不知道密钥的情况下，为一个已知的`hash(key || message)`和附加数据，计算出一个新的、有效的`hash(key || message || padding || new_data)`。

**4. Merkle树构建与存在性证明**

- 成功实现了基于SM3、包含**10万**叶子节点的Merkle树的构建。
- 成功实现了为树中任一叶子节点生成其存在性证明的功能，并通过了验证，证明该叶子确实存在于树中。

### 执行截图

![image-20250805150723560](./../AppData/Roaming/Typora/typora-user-images/image-20250805150723560.png)

![image-20250805150733015](./../AppData/Roaming/Typora/typora-user-images/image-20250805150733015.png)

![image-20250805150748968](./../AppData/Roaming/Typora/typora-user-images/image-20250805150748968.png)

### 目录结构

```
sm3-project4/
├── src/
│   ├── sm3_basic/               # SM3 基础实现 
│   ├── sm3_optimized/           # SM3 优化实现框架 
│   ├── length_extension_attack/ # 长度扩展攻击逻辑 
│   └── merkle_tree/             # Merkle树逻辑 
├── tests/
│   ├── test_sm3.c               # SM3 统一测试驱动
│   ├── test_attack.c            # 攻击测试驱动
│   └── test_merkle.c            # Merkle树测试驱动
└── Makefile                     # 项目编译脚本
└── README.md
```

### 项目代码模块说明

#### 1. SM3 基础与优化模块 (`src/`)

##### **`sm3.h` - SM3算法接口头文件**

- **思路说明**:
  - 该文件是SM3哈希函数库的“公共接口”（API）。它定义了外部调用者需要使用的所有数据结构和函数。
  - `sm3_ctx_t` 结构体被设计用于支持“流式计算”，即可以分多次向算法提供数据（通过`sm3_update`），这对于处理大文件非常重要。
  - 除了标准的`init`, `update`, `final`函数外，特别提供了`sm3_init_with_state`函数。这个非标准的接口是实现长度扩展攻击的关键，它允许我们用一个已知的哈希结果作为初始状态来“续算”哈希。

##### **`sm3.c` - SM3基础算法实现**

- **思路说明**:
  - 该文件严格按照SM3官方标准文档的步骤，实现了最基础、最原始的SM3算法。其首要目标是**正确性**，而不是性能。
  - 代码逻辑清晰地分为几个部分：消息填充（Padding）、消息扩展（Message Expansion）和核心的迭代压缩函数（`sm3_compress`）。
  - 它作为整个项目的基石，是所有其他功能（攻击、Merkle树）和性能优化版本的参照标准。

##### **`sm3_unrolled.c` - 循环展开优化版**

- **思路说明**:
  - 该文件是SM3的第一个性能优化尝试。核心思路是**循环展开（Loop Unrolling）**。
  - 在标准的`sm3_compress`函数中，64轮的迭代压缩是通过一个`for`循环实现的。循环本身会带来额外的计算开销（如循环变量的增减和判断、分支跳转等）。
  - 此文件通过使用宏（`SM3_ROUND`）将这64轮计算在代码中完全展开，从而消除了循环开销，并为编译器提供了更大的指令级并行（Instruction-Level Parallelism）优化空间。

##### **`sm3_simd.c` - SIMD优化版框架**

- **思路说明**:
  - 该文件旨在实现最高性能的SM3算法，其核心思路是**单指令多数据流（SIMD）**。
  - 现代CPU（如支持AVX指令集的Intel/AMD CPU）的寄存器可以一次性装载并处理多个数据（例如，一个256位的AVX寄存器可以同时处理8个32位整数）。
  - 通过重新组织数据，我们可以并行处理2个、4个甚至8个消息分组，从而将计算效率提升数倍。
  - 当前版本提供了一个可编译的**完整框架**，内部暂时使用基础逻辑作为占位符。项目的核心优化任务就是在这个框架内，使用`_mm256_add_epi32`等SIMD内联函数（Intrinsics）来替换原有的标量计算。

#### 2. 应用与验证模块 (`src/` & `tests/`)

##### **`attack.c` - 长度扩展攻击逻辑**

- **思路说明**:
  - 该文件封装了实现长度扩展攻击的核心逻辑。它利用了Merkle-Damgård结构的哈希函数（如MD5, SHA1, SM3）的一个固有特性。
  - 攻击的核心在于，如果我们知道`hash(secret || message)`的结果和`secret`的长度，我们就能在不知道`secret`内容的情况下，计算出`hash(secret || message || padding || new_data)`。
  - `forge_sm3`函数精确地模拟了哈希算法对原始消息的填充过程，计算出正确的`padding`，然后调用特殊的`sm3_init_with_state`函数，将已知的哈希结果作为初始IV，继续对`new_data`进行哈希计算，从而伪造出最终的哈希。

##### **`merkle.h` & `merkle.c` - Merkle树库**

- **思路说明**:
  - `merkle.h`定义了构建和操作Merkle树的接口，`merkle.c`提供了具体实现。
  - **树的构建 (`build_merkle_tree`)**: 采用递归思路。每一层将相邻的两个节点的哈希值拼接起来，再计算上一层父节点的哈希，直到最终只剩一个根节点。为了处理奇数个节点的情况，会将该层的最后一个节点复制一份与自身进行哈希。
  - **存在性证明 (`get_existence_proof`)**: 为了证明一个叶子存在，我们只需要提供从该叶子到树根路径上所有节点的“兄弟节点”的哈希值。
  - **证明验证 (`verify_existence_proof`)**: 验证者从已知的叶子哈希开始，利用证明中提供的兄弟哈希，逐层向上计算父哈希，最终得出的根哈希如果与已知的公开根哈希一致，则证明该叶子确实存在于树中。

##### **`test_sm3.c`, `test_attack.c`, `test_merkle.c` - 测试驱动程序**

- **思路说明**:

  - 这三个文件是整个项目的“驱动程序”，它们各自包含一个`main`函数，是程序执行的入口。
  - 它们的作用是**调用**前面所述的库函数，来完成一个具体的任务，并打印出结果，从而验证库功能的正确性。
  - **`test_sm3.c`**: 使用SM3官方标准给出的测试向量（如"abc"的哈希值），来验证我们实现的各个SM3版本（基础版、优化版）是否正确。
  - **`test_attack.c`**: 设置一个具体的攻击场景（如伪造一个包含`&role=admin`的URL参数），调用`attack.c`中的逻辑，并最终验证伪造的哈希是否与真实哈希一致。
  - **`test_merkle.c`**: 模拟一个真实场景，创建大量（10万个）叶子节点，调用`merkle.c`构建树，然后随机选取一个叶子，为其生成并验证存在性证明。

  

### 编译与运行

本项目需在 **MSYS2 UCRT64** 环境下进行编译。

**1. 编译项目**

进入项目根目录，执行`mingw32-make`命令即可编译所有目标：

```
mingw32-make
```

**2. 运行测试程序**

编译成功后，会在根目录下生成多个`.exe`可执行文件。可分别运行它们来查看各个模块的测试结果：

```tex
# 运行基础版SM3测试
./test_sm3_basic.exe

# 运行循环展开优化版SM3测试
./test_sm3_unrolled.exe

# 运行SIMD占位版SM3测试
./test_sm3_simd.exe

# 运行长度扩展攻击验证
./test_attack.exe

# 运行Merkle树构建与存在性证明验证
./test_merkle.exe
```
